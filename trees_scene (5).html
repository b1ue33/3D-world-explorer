<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Perlin Hills with Water + Trees</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000}
  #overlay{position:fixed;top:10px;left:10px;color:#fff;background:rgba(0,0,0,0.4);padding:6px;border-radius:6px;font-family:sans-serif;font-size:12px;display:none}
  canvas{display:block}
  #startScreen {position:absolute;top:0;left:0;width:100%;height:100%;background:#222;display:flex;flex-direction:column;justify-content:center;align-items:center;color:#fff;font-family:sans-serif;}
  #startScreen h1 {font-size:48px;margin-bottom:40px;}
  #startScreen button {font-size:20px;padding:10px 20px;margin:10px;cursor:pointer;border:none;border-radius:8px;}
  #optionsMenu {display:none;flex-direction:column;align-items:center;}
  #optionsMenu label {margin:10px;}
</style>
</head>
<body>
<div id="startScreen">
  <h1>3D WORLD EXPLORER</h1>
  <button id="startBtn">Start</button>
  <button id="optionsBtn">Options</button>
  <div id="optionsMenu">
    <label>Render Distance: <input id="renderDistance" type="number" value="2000" min="500" max="5000"></label>
    <label>Terrain Intensity: <input id="terrainIntensity" type="number" value="40" min="10" max="80"></label>
    <button id="backBtn">Back</button>
  </div>
</div>
<div id="overlay">Click canvas. WASD move, Space jump, Shift down, Z toggle fly</div>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

// --- Simple Perlin Noise ---
function fade(t){return t*t*t*(t*(t*6-15)+10);}
function lerp(t,a,b){return a+t*(b-a);}
function grad(hash,x,y){
  const h=hash&15;
  const u=h<8?x:y;
  const v=h<4?y: (h===12||h===14?x:0);
  return ((h&1)?-u:u)+((h&2)?-v:v);
}
class Perlin{
  constructor(){
    this.p=new Uint8Array(512);
    const perm=[151,160,137,91,90,15,
      131,13,201,95,96,53,194,233,7,225,140,36,103,30,
      69,142,8,99,37,240,21,10,23,
      190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
      88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,
      77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
      102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,
      130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,
      38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,
      183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,
      129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,
      34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,
      192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,
      236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
    for(let i=0;i<512;i++) this.p[i]=perm[i&255];
  }
  noise(x,y){
    const X=Math.floor(x)&255;
    const Y=Math.floor(y)&255;
    x-=Math.floor(x); y-=Math.floor(y);
    const u=fade(x), v=fade(y);
    const A=this.p[X]+Y, B=this.p[X+1]+Y;
    return lerp(v,
      lerp(u, grad(this.p[A],x,y), grad(this.p[B],x-1,y)),
      lerp(u, grad(this.p[A+1],x,y-1), grad(this.p[B+1],x-1,y-1))
    )*0.5+0.5;
  }
}
const perlin=new Perlin();

// renderer + scene
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);

// camera
let camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,2000);
camera.position.set(0,400,120); // spawn higher up
camera.lookAt(0,0,0);

// lights
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,0.9));
const sun=new THREE.DirectionalLight(0xffffff,0.9);
sun.position.set(100,200,100);
scene.add(sun);

// constants
const SIZE=400, SEG=128, WATER_LEVEL=20;

// terrain geometry function
function generateTerrain(intensity){
  const geom=new THREE.PlaneGeometry(SIZE,SIZE,SEG,SEG);
  geom.rotateX(-Math.PI/2);
  const verts=geom.attributes.position;
  for(let i=0;i<verts.count;i++){
    const x=verts.getX(i), z=verts.getZ(i);
    const h=(perlin.noise(x*0.02,z*0.02)+0.3*perlin.noise(x*0.05,z*0.05))*intensity;
    verts.setY(i,h);
  }
  geom.computeVertexNormals();
  return geom;
}

let terrainIntensity=40;
const ground=new THREE.Mesh(generateTerrain(terrainIntensity),new THREE.MeshStandardMaterial({color:0x7CFC00}));
ground.name="ground";
scene.add(ground);

// water
const water=new THREE.Mesh(
  new THREE.PlaneGeometry(SIZE*3,SIZE*3),
  new THREE.MeshPhongMaterial({color:0x1e90ff,transparent:true,opacity:0.6})
);
water.rotation.x=-Math.PI/2;
water.position.y=WATER_LEVEL;
water.name="water";
scene.add(water);

// store colliders
const colliders=[];

// --- Generate simple trees ---
const trunkMat=new THREE.MeshStandardMaterial({color:0x8B4513});
const leavesMat=new THREE.MeshStandardMaterial({color:0x006400});

for(let i=0;i<200;i++){
  const x=(Math.random()-0.5)*SIZE;
  const z=(Math.random()-0.5)*SIZE;
  const h=(perlin.noise(x*0.02,z*0.02)+0.3*perlin.noise(x*0.05,z*0.05))*terrainIntensity;
  if(h>WATER_LEVEL+2){
    const trunk=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,4,6),trunkMat);
    trunk.position.set(x,h+2,z);
    trunk.name="trunk";
    const leaves=new THREE.Mesh(new THREE.ConeGeometry(3,6,8),leavesMat);
    leaves.position.set(x,h+7,z);
    leaves.name="leaves";
    scene.add(trunk);
    scene.add(leaves);
    colliders.push(trunk);
  }
}

// --- Generate rocks ---
const rockMat=new THREE.MeshStandardMaterial({color:0x808080});
for(let i=0;i<80;i++){
  const x=(Math.random()-0.5)*SIZE;
  const z=(Math.random()-0.5)*SIZE;
  const h=(perlin.noise(x*0.02,z*0.02)+0.3*perlin.noise(x*0.05,z*0.05))*terrainIntensity;
  const rockSize=Math.random()*2+1;
  const rock=new THREE.Mesh(new THREE.DodecahedronGeometry(rockSize),rockMat);
  rock.position.set(x,h+rockSize/2,z);
  rock.name="rock";
  scene.add(rock);
  colliders.push(rock);
}

// movement
let yaw=0,pitch=0,flying=false; // ensure flying starts off false
const vel=new THREE.Vector3();
const move={f:0,b:0,l:0,r:0,up:0,down:0};

function enableControls(){
  document.addEventListener("click",()=>renderer.domElement.requestPointerLock());
  document.addEventListener("mousemove",e=>{
    if(document.pointerLockElement!==renderer.domElement) return;
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
  });
  document.addEventListener("keydown",e=>{
    if(e.code==="KeyS") move.f=1;
    if(e.code==="KeyW") move.b=1;
    if(e.code==="KeyD") move.l=1;
    if(e.code==="KeyA") move.r=1;
    if(e.code==="Space") move.up=1;
    if(e.code==="ShiftLeft") move.down=1;
    if(e.code==="KeyZ") flying=!flying;
  });
  document.addEventListener("keyup",e=>{
    if(e.code==="KeyS") move.f=0;
    if(e.code==="KeyW") move.b=0;
    if(e.code==="KeyD") move.l=0;
    if(e.code==="KeyA") move.r=0;
    if(e.code==="Space") move.up=0;
    if(e.code==="ShiftLeft") move.down=0;
  });
}

let last=performance.now();
const raycaster=new THREE.Raycaster();

function animate(t){
  const dt=(t-last)/1000; last=t;
  const dir=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();
  let speed=50;

  // water slowdown
  if(camera.position.y<=WATER_LEVEL+2){
    speed=20;
  }

  vel.x=(move.f-move.b)*dir.x*speed+(move.r-move.l)*right.x*speed;
  vel.z=(move.f-move.b)*dir.z*speed+(move.r-move.l)*right.z*speed;

  if(flying){
    vel.y=(move.up-move.down)*speed;
  } else {
    vel.y+=-98*dt;
    // collision with ground using raycast down
    raycaster.set(camera.position,new THREE.Vector3(0,-1,0));
    const intersects=raycaster.intersectObject(ground);
    if(intersects.length>0){
      const groundY=intersects[0].point.y+5;
      if(camera.position.y<=groundY){
        camera.position.y=groundY;
        vel.y=move.up?30:0;
      }
    }
  }

  // apply velocity
  camera.position.addScaledVector(vel,dt);
  camera.quaternion.setFromEuler(new THREE.Euler(pitch,yaw,0,"YXZ"));

  // basic collision with trees/rocks
  for(const obj of colliders){
    const dist=camera.position.distanceTo(obj.position);
    if(dist<3){
      const push=new THREE.Vector3().subVectors(camera.position,obj.position).normalize();
      camera.position.addScaledVector(push,1);
    }
  }

  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}

// Start screen logic
const startScreen=document.getElementById("startScreen");
const startBtn=document.getElementById("startBtn");
const optionsBtn=document.getElementById("optionsBtn");
const optionsMenu=document.getElementById("optionsMenu");
const backBtn=document.getElementById("backBtn");
const renderDistanceInput=document.getElementById("renderDistance");
const terrainIntensityInput=document.getElementById("terrainIntensity");

startBtn.onclick=()=>{
  startScreen.style.display="none";
  document.getElementById("overlay").style.display="block";
  camera.far=parseFloat(renderDistanceInput.value);
  terrainIntensity=parseFloat(terrainIntensityInput.value);
  camera.updateProjectionMatrix();
  enableControls();
  animate(performance.now());
};

optionsBtn.onclick=()=>{
  optionsMenu.style.display="flex";
  startBtn.style.display="none";
  optionsBtn.style.display="none";
};

backBtn.onclick=()=>{
  optionsMenu.style.display="none";
  startBtn.style.display="inline-block";
  optionsBtn.style.display="inline-block";
};

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
